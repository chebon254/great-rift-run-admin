{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///home/kibet/Dev/great-rift-run-admin/src/app/api/products/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport async function POST(request: Request) {\n  try {\n    const formData = await request.formData();\n    \n    const productData = {\n      category: formData.get('category') as string,\n      name: formData.get('name') as string,\n      description: formData.get('description') as string,\n      price: parseFloat(formData.get('price') as string),\n      inStock: parseInt(formData.get('inStock') as string),\n      color: formData.get('color') as string,\n      material: formData.get('material') as string,\n    };\n\n    // Validate required fields\n    const missingFields = [];\n    if (!productData.name) missingFields.push('name');\n    if (!productData.category) missingFields.push('category');\n    if (isNaN(productData.price)) missingFields.push('price');\n    if (isNaN(productData.inStock)) missingFields.push('inStock');\n    \n    if (missingFields.length > 0) {\n      return NextResponse.json({\n        error: 'Missing required fields',\n        missingFields\n      }, { status: 400 });\n    }\n\n    // Handle image uploads\n    const imageUrls: string[] = [];\n    for (let i = 0; i < 4; i++) {\n      const imageFile = formData.get(`image${i}`);\n      if (imageFile instanceof File) {\n        // For now, we'll store a placeholder URL since image upload is not implemented\n        imageUrls.push(`/products/product_${i + 1}.jpg`);\n      }\n    }\n\n    // Save product to database\n    const product = await prisma.product.create({\n      data: {\n        ...productData,\n        imageURL1: imageUrls[0] || null,\n        imageURL2: imageUrls[1] || null,\n        imageURL3: imageUrls[2] || null,\n        imageURL4: imageUrls[3] || null,\n      },\n    });\n\n    return NextResponse.json(product, { status: 201 });\n  } catch (error) {\n    console.error('Failed to create product:', error);\n    return NextResponse.json({\n      error: 'Failed to save product',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\nexport async function GET() {\n  try {\n    const products = await prisma.product.findMany({\n      orderBy: {\n        createdAt: 'desc'\n      },\n      where: {\n        deletedAt: null\n      }\n    });\n      \n    return NextResponse.json(products);\n  } catch (error) {\n    console.error('Failed to fetch products:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch products' },\n      { status: 500 }\n    );\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\nexport async function DELETE(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const id = parseInt(url.pathname.split('/').pop() || '');\n\n    if (isNaN(id)) {\n      return NextResponse.json({ error: 'Invalid product ID' }, { status: 400 });\n    }\n\n    await prisma.product.update({\n      where: { id },\n      data: { deletedAt: new Date() }\n    });\n\n    return NextResponse.json({ message: 'Product deleted successfully' });\n  } catch (error) {\n    console.error('Failed to delete product:', error);\n    return NextResponse.json(\n      { error: 'Failed to delete product' },\n      { status: 500 }\n    );\n  } finally {\n    await prisma.$disconnect();\n  }\n}"],"names":[],"mappings":";;;;;AAAA;AACA;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QAEvC,MAAM,cAAc;YAClB,UAAU,SAAS,GAAG,CAAC;YACvB,MAAM,SAAS,GAAG,CAAC;YACnB,aAAa,SAAS,GAAG,CAAC;YAC1B,OAAO,WAAW,SAAS,GAAG,CAAC;YAC/B,SAAS,SAAS,SAAS,GAAG,CAAC;YAC/B,OAAO,SAAS,GAAG,CAAC;YACpB,UAAU,SAAS,GAAG,CAAC;QACzB;QAEA,2BAA2B;QAC3B,MAAM,gBAAgB,EAAE;QACxB,IAAI,CAAC,YAAY,IAAI,EAAE,cAAc,IAAI,CAAC;QAC1C,IAAI,CAAC,YAAY,QAAQ,EAAE,cAAc,IAAI,CAAC;QAC9C,IAAI,MAAM,YAAY,KAAK,GAAG,cAAc,IAAI,CAAC;QACjD,IAAI,MAAM,YAAY,OAAO,GAAG,cAAc,IAAI,CAAC;QAEnD,IAAI,cAAc,MAAM,GAAG,GAAG;YAC5B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP;YACF,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,uBAAuB;QACvB,MAAM,YAAsB,EAAE;QAC9B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,MAAM,YAAY,SAAS,GAAG,CAAC,CAAC,KAAK,EAAE,GAAG;YAC1C,IAAI,qBAAqB,MAAM;gBAC7B,+EAA+E;gBAC/E,UAAU,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,EAAE,IAAI,CAAC;YACjD;QACF;QAEA,2BAA2B;QAC3B,MAAM,UAAU,MAAM,OAAO,OAAO,CAAC,MAAM,CAAC;YAC1C,MAAM;gBACJ,GAAG,WAAW;gBACd,WAAW,SAAS,CAAC,EAAE,IAAI;gBAC3B,WAAW,SAAS,CAAC,EAAE,IAAI;gBAC3B,WAAW,SAAS,CAAC,EAAE,IAAI;gBAC3B,WAAW,SAAS,CAAC,EAAE,IAAI;YAC7B;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,SAAS;YAAE,QAAQ;QAAI;IAClD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GAAG;YAAE,QAAQ;QAAI;IACnB,SAAU;QACR,MAAM,OAAO,WAAW;IAC1B;AACF;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM,OAAO,OAAO,CAAC,QAAQ,CAAC;YAC7C,SAAS;gBACP,WAAW;YACb;YACA,OAAO;gBACL,WAAW;YACb;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,MAAM,OAAO,WAAW;IAC1B;AACF;AAEO,eAAe,OAAO,OAAgB;IAC3C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC/B,MAAM,KAAK,SAAS,IAAI,QAAQ,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM;QAErD,IAAI,MAAM,KAAK;YACb,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAqB,GAAG;gBAAE,QAAQ;YAAI;QAC1E;QAEA,MAAM,OAAO,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBAAE;YAAG;YACZ,MAAM;gBAAE,WAAW,IAAI;YAAO;QAChC;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA+B;IACrE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,MAAM,OAAO,WAAW;IAC1B;AACF"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}